from math import isclose
import scipy.optimize._differentialevolution as de
import numpy as np
import torch
import torch.nn as nn

class SiameseNetwork(nn.Module):
    #孿生網路
    def __init__(self):
        super(SiameseNetwork, self).__init__()
        self.cnn = nn.Sequential(
                nn.Conv2d(3, 16, kernel_size=3),
                nn.ReLU(inplace=True),
                nn.MaxPool2d(2, 2),

                nn.Conv2d(16, 32, kernel_size=2),
                nn.ReLU(inplace=True),
                nn.MaxPool2d(2, 2),

                nn.Conv2d(32, 64, kernel_size=2),
                nn.ReLU(inplace=True)
        )

        self.fc1 = nn.Sequential(
                nn.Linear(14*14*64, 128)
        )

        self.fc2 = nn.Sequential(
                nn.Linear(128, 1),
                nn.Sigmoid()
        )

    def forward_once(self, x):
        output = self.cnn(x)
        output = output.view(output.size()[0], -1)
        output = self.fc1(output)
        return output

    def forward(self, input1, input2):
        output1 = self.forward_once(input1)
        output2 = self.forward_once(input2)
        output = torch.abs(output1 - output2)
        output = self.fc2(output)
        return output

import new_test as sia_model
import os
import pandas as pd
import cv2

target_class = "benign"

orig_family_name = "xorist"

dimensions=(16, 16)


def perturb_image(xs, img):
    # If this function is passed just one perturbation vector,
    # pack it in a list to keep the computation the same
    if xs.ndim < 2:
        xs = np.array([xs])
    
    # Copy the image n == len(xs) times so that we can 
    # create n new perturbed images
    tile = [len(xs)] + [1]*(xs.ndim+1)
    imgs = np.tile(img, tile)
    
    # Make sure to floor the members of xs as int types
    xs = xs.astype(int)
    
    for x,img in zip(xs, imgs):
        # Split x into an array of 5-tuples (perturbation pixels)
        # i.e., [[x,y,r,g,b], ...]
        pixels = np.split(x, len(x) // 5)
        for pixel in pixels:
            # At each pixel's x,y position, assign its rgb value
            x_pos, y_pos, *rgb = pixel
            img[x_pos, y_pos] = rgb
    return imgs

def predict_classes(xs, img, model):
    # Perturb the image with the given pixel(s) x and get the prediction of the model
    imgs_perturbed = perturb_image(xs, img)
    imgs_perturbed = imgs_perturbed[0,:,:,:]
    predictions = model.predict_img(imgs_perturbed)[0]
    # result = np.array([p[0] for p in predictions])
    return 1 - predictions

def attack_success(x, img, model):
    # Perturb the image with the given pixel(s) and get the prediction of the model
    attack_image = perturb_image(x, img)[0]
    t_label = model.predict_img(attack_image)[1]
    return t_label == target_class

def attack(img_id, orig_image, model, pixel_count=1, maxiter=75, popsize=400):
    # Define bounds for a flat vector of x,y,r,g,b values
    # For more pixels, repeat this layout
    dim_x, dim_y = dimensions
    bounds = [(0, dim_x), (0, dim_y), (0, 256), (0, 256), (0, 256)] * pixel_count

    # Population multiplier, in terms of the size of the perturbation vector x
    popmul = max(1, popsize // len(bounds))

    # Format the predict/callback functions for the differential evolution algorithm
    def predict_fn(xs):
        return predict_classes(xs, orig_image, model)

    def callback_fn(x, convergence):
        return attack_success(x, orig_image, model)

    # Call Scipy's Implementation of Differential Evolution
    attack_result = de.differential_evolution(
        predict_fn, bounds, maxiter=maxiter, popsize=popmul,
        recombination=1, atol=-1, callback=callback_fn, polish=False)

    # Calculate some useful statistics to return from this function
    attack_image = perturb_image(attack_result.x, orig_image)[0]
    orig_predict = model.predict_img(orig_image)
    orig_predict_confidence = orig_predict[0]
    orig_predict_class = orig_predict[1]

    attack_predict = model.predict_img(attack_image)
    attack_predict_confidence = attack_predict[0]
    attack_predict_class = attack_predict[1]
    success = attack_predict_class == target_class

    return [img_id, pixel_count, str(attack_result.x), orig_family_name, orig_predict_class, orig_predict_confidence, 
                                                    attack_predict_class, attack_predict_confidence, success], attack_image

def save_attack_img(img_name, family_name, attack_img):
    folder = "C:/Users/jack8/Desktop/Mid_Project/attack_images/" + family_name
    if not os.path.exists(folder):
        os.makedirs(folder)
    cv2.imwrite(folder + '/' + img_name, attack_img)

def append_record(data, record):
    data['Image Id'].append(record[0])
    data['Pixel Count'].append(record[1])
    data['Attack Pixel'].append(record[2])
    data['True Family'].append(record[3])
    data['Original Predict'].append(record[4])
    data['Original Confidence'].append(record[5])
    data['Attack Predict'].append(record[6])
    data['Attack Confidence'].append(record[7])
    data['Success'].append(record[8])

if __name__ == '__main__':
    data_set_path = "C:/Users/jack8/Desktop/Mid_Project/test/xorist"
    data = {'Image Id': [], 'Pixel Count': [], 'Attack Pixel': [], 'True Family': [], 'Original Predict': [],
        'Original Confidence': [], 'Attack Predict': [], 'Attack Confidence': [], 'Success':[]}

    for filename in os.listdir(data_set_path):
        image_path = data_set_path + "/" + filename
        target_image = cv2.imread(image_path)
        record, attack_img = attack(filename.split(".")[0], target_image, sia_model)
        append_record(data, record)
        save_attack_img(filename, orig_family_name, attack_img)
    pd.DataFrame(data).to_excel("C:/Users/jack8/Desktop/Mid_Project/attack_result.xlsx", index=False)